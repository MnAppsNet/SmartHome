try:
    import RPi.GPIO as GPIO
except:
    GPIO = None #For testing purposes
import json, pytz
from handlers.dataHandler import Data, DATA_KEY
from const import Constants
from handlers.stateLogsHandler import StateLogs
from datetime import datetime, timedelta
import hashlib, requests

'''
This script is working with a heat element that can be enabled and disabled by connection or reconnecting
two cables, like a switch. These cables can be bridged with the Collector and the Emitter of a BJT transistor
and the switch can be done by providing a positive voltage between the Base and the Emitter of the transistor.
'''

#Constants
DEFAULT_THRESHOLD_TEMPERATURE = 20
DEFAULT_TEMPERATURE_OFFSET = 0.2
MAX_TEMPERATURE_OFFSET = 2
class Thermostat:
    def __init__(self, dataHandler:Data = None):
        self._data = dataHandler
        self._pin = self._data.getValue(DATA_KEY.thermostat)
        if self._pin == None: #The pin where the heat switch is connected or the IP of the remote switch
            self._pin = Constants.THERMOSTAT_PIN
            self._data.setValue(DATA_KEY.thermostat,self._pin)
        self._isRemote = Thermostat.CheckIPThermostat(self._pin)
        if (self._isRemote):
            self._pin = str(self._pin)
            if not self._pin.endswith("/"): self._pin += "/"
            if not self._pin.starswith("http"): self._pin = "http://"+self._pin
        self._off = False                    #Thermostat is not off and it is working
        if GPIO != None:
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BOARD)
            GPIO.setup(self._pin, GPIO.OUT, initial=False)

    def CheckIPThermostat(thermostat):
        thermostat = str(thermostat)
        if ('.' in thermostat or ':' in thermostat):
            return True
        return False

    def _setHeatState(self,state):
        if state == True:
            #If we are about to open the heat, check if thermostat is off
            self._off = self._getThermostatState()
        if self._off == True: state = False #Can't enable heat when thermostat is off
        if self._isRemote: #Remote thermostat IP -> Change State
            for _ in range(3):#Try 3 times
                if state: state = "on" 
                else: state = "off"
                request_uri = self._pin+"/set?state="+state
                response = requests.get(request_uri) #Get PIN generated by thermostat
                #Get the hash of the retrieved PIN along with the secret
                secret = self._data.getValue(DATA_KEY.thermostatSecret)
                if secret == None: secret = ""
                hash = hashlib.md5(response.text+secret).hexdigest()
                #Send state change request with the correct hash for authentication
                response = requests.get(self._pin+"/set?state="+state,headers={Constants.REQUEST_HEADER_HASH:hash})
                if response.text.lower().endswith(" "+state):
                    break
            #Get final state
            state = requests.get(self._pin)
            if state.text.lower() == "on": state = True
            else: state = False
        else: #Thermostat PIN -> Change State
            if GPIO != None:
                GPIO.output(self._pin,state)
            else:
                print("-----")
                print("A physical PIN thermostat was configured but GPIO module is not installed.")
                print("Please install GPIO module or define the IP of a remote thermostat.")
                print("-----")
        return state

    def _getThermostatState(self):
        if self._data == None:
            return self._off
        self._off = self._data.getValue(DATA_KEY.thermostatOff)
        return self._off

    def _getTemperatureThreshold(self):
        if self._data == None:
            return DEFAULT_THRESHOLD_TEMPERATURE
        threshold = self._data.getValue(DATA_KEY.requiredTemperature)
        if type(threshold) != float:
            threshold = float(threshold)
        return threshold

    def _getTemperatureSchedule(self):
        if self._data == None:
            return None
        return self._data.getValue(DATA_KEY.schedule)

    def _getTemperatureOffset(self):
        if self._data == None:
            return DEFAULT_TEMPERATURE_OFFSET
        return self._data.getValue(DATA_KEY.temperatureOffset)

    def _logStateChanges(self,currentState,prevState,temperature,threshold):
        if prevState == currentState:
            return #State not changed
        StateLogs.addEntry(currentState,temperature,threshold)

    def setTemperatureThreshold(self,temperature):
        try:
            if type(temperature) != float:
                temperature = float(temperature)
        except:
            return
        if self._data != None:
            self._data.setValue(DATA_KEY.requiredTemperature,temperature)

    def setTemperatureOffset(self,offset):
        if self._data != None:
            self._data.setValue(DATA_KEY.temperatureOffset,offset)

    def checkTemperatureSchedule(self):
        '''
        Check the temperature schedules defined and change the required temperature accordingly
        '''
        schedule = self._getTemperatureSchedule()
        if schedule == None: return
        #Get the current time in a numeric format that can be compared :
        currentTime = int(datetime.now(pytz.timezone(Constants.TIMEZONE)).strftime("%H%M%S"))
        #Get current refresh rate and take it into consideration (we don't wont to skip any schedule) :
        refreshRate = None
        if self._data != None:
            refreshRate = self._data.getValue(DATA_KEY.refreshRate)
        if refreshRate == None:
            refreshRate = 60
        prevTime = int((datetime.now(pytz.timezone(Constants.TIMEZONE)) - timedelta(seconds=refreshRate)).strftime("%H%M%S"))
        #Check all defined temperature schedules :
        for key in schedule:
            #Convert key into number to be compared :
            time = key.split(':')
            if len(time) != 2: continue
            time = time[0] + time[1] + '00'
            time = int(time)
            #Check if schedule applies and if yes set required temperature :
            if (time >= prevTime and time <= currentTime ):
                self.setTemperatureThreshold(schedule[key])
                break

    def checkState(self,temperature):
        '''
        Check the thermostat state and set it according to required temperature
        '''
        actualState = False
        prevState = self._data.getValue(DATA_KEY.thermostatState)
        threshold = self._getTemperatureThreshold()
        offset = self._getTemperatureOffset()
        if temperature < threshold: #It's cold...
            #Turn heat on
            actualState = True
        elif prevState == True and temperature < threshold + offset:
            #If it was previously turned on and the new temp is not reached yet
            #Keep the heat on
            actualState = True

        actualState = self._setHeatState(actualState)

        #Get the actual state of the thermostat
        if self._data != None:
            self._logStateChanges(actualState,prevState,temperature,threshold)
            self._data.setValue(DATA_KEY.thermostatState,actualState)

        return actualState